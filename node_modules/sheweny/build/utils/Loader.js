"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Loader = void 0;
const discord_js_1 = require("discord.js");
const index_js_1 = require("../helpers/index.js");
const promises_1 = require("fs/promises");
const node_path_1 = require("node:path");
class Loader {
    constructor(client, path, mainKey, options) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collection", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "mainKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "mainPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "paths", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "manager", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "asyncRead", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "instance", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.collection = new discord_js_1.Collection();
        this.mainPath = this.absolutePath(path);
        this.paths = [];
        this.mainKey = mainKey;
        this.manager = options.manager;
        this.instance = options.instance;
        this.asyncRead = options.asyncRead ?? false;
    }
    // Load all structures
    async load(dir = this.mainPath) {
        if (dir)
            await this.readDirectory(this.absolutePath(dir));
        else if (this.mainPath)
            await this.readDirectory(this.mainPath);
        else
            new index_js_1.ShewenyError(this.client, 'MISSING_PATH_LOADER');
        if (!this.paths.length)
            return this.collection;
        if (this.asyncRead) {
            await Promise.all(this.paths.map(async (path) => await this.loadFileStructures(path)));
        }
        else {
            for (const path of this.paths) {
                await this.loadFileStructures(path);
            }
        }
        // Return the collection
        return this.collection;
    }
    absolutePath(...dir) {
        let main = '';
        if (require.main)
            main = require.main.path;
        else if (!main)
            main = process.cwd();
        if (dir)
            main = (0, node_path_1.resolve)(main, ...dir);
        else
            main = (0, node_path_1.resolve)(main);
        return main;
    }
    async readDirectory(dir) {
        const result = await (0, promises_1.readdir)(dir);
        if (this.asyncRead) {
            await Promise.all(result.map(async (file) => {
                const path = (0, node_path_1.resolve)(dir, file);
                const stats = await (0, promises_1.stat)(path);
                if (stats.isDirectory())
                    return this.readDirectory(path);
                else if ((stats.isFile() && file.endsWith('.js')) || file.endsWith('.ts'))
                    this.paths.push(path);
            }));
        }
        else {
            for (const file of result) {
                const path = (0, node_path_1.resolve)(dir, file);
                const stats = await (0, promises_1.stat)(path);
                if (stats.isDirectory())
                    await this.readDirectory(path);
                else if ((stats.isFile() && file.endsWith('.js')) || file.endsWith('.ts'))
                    this.paths.push(path);
            }
        }
    }
    async loadFileStructures(path) {
        try {
            const imported = await Promise.resolve().then(() => __importStar(require(path)));
            const keys = Object.keys(imported);
            if (keys.length) {
                for (const key of keys) {
                    await this.loadStructure(imported[key], path);
                }
            }
            else {
                await this.loadStructure(imported, path);
            }
        }
        catch (err) {
            const error = err;
            new index_js_1.ShewenyError(this.client, 'LOAD_ERROR', path, error.message);
        }
    }
    async loadStructure(StructureToLoad, path) {
        try {
            if (StructureToLoad['_id'] != 'ShewenyLoadable')
                return;
            const instance = new StructureToLoad(this.client);
            if (!instance)
                return;
            // Bad instance
            if (!(instance instanceof this.instance))
                return;
            if (!Object.hasOwn(instance, this.mainKey)) {
                return new index_js_1.ShewenyWarning(this.client, 'MISSING_PROPERTY_CLASS', this.mainKey, path);
            }
            let set = [instance];
            const get = this.collection.get(instance[this.mainKey]);
            if (get) {
                get.push(instance);
                set = get;
            }
            // Set data on structure
            instance.path = path;
            instance.manager = this.manager;
            return this.collection.set(instance[this.mainKey], set);
        }
        catch (err) {
            const error = err;
            return new index_js_1.ShewenyWarning(this.client, 'INVALID_CLASS', StructureToLoad.toString(), path, error);
        }
    }
}
exports.Loader = Loader;
//# sourceMappingURL=Loader.js.map