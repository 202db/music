"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandsManager = void 0;
const discord_js_1 = require("discord.js");
const Loader_js_1 = require("../utils/Loader.js");
const index_js_1 = require("../helpers/index.js");
const index_js_2 = require("./index.js");
const constants_js_1 = require("../constants/constants.js");
const index_js_3 = require("../structures/index.js");
/**
 * Manager for Commands
 * @extends {EventEmitter}
 */
class CommandsManager extends index_js_2.BaseManager {
    /**
     * Constructor of commands manager
     * @param {ShewenyClient} client Client framework
     * @param {CommandsManagerOptions} [options] Options of the commands manager
     */
    constructor(client, options) {
        super(client, options);
        /**
         * If the applications commands are disabled according to the `userPermissions` array
         * @type {boolean | undefined}
         */
        Object.defineProperty(this, "applicationPermissions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Register application commands
         * @type {boolean}
         */
        Object.defineProperty(this, "autoRegisterApplicationCommands", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Collection of the commands
         * @type {Collection<string, Command[]> | undefined}
         */
        Object.defineProperty(this, "commands", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Default data for the commands
         * @type {CommandsManagerDefaultOptions}
         */
        Object.defineProperty(this, "default", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * ID of the guild where are set Applications Commands
         * @type {Snowflake | Snowflake[] | undefined}
         */
        Object.defineProperty(this, "guildId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Prefix for the Message Commands
         * @type {string | undefined}
         */
        Object.defineProperty(this, "prefix", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The strategy for register application commands
         * @type {CommandManagerRegisterStrategy}
         */
        Object.defineProperty(this, "registerStrategy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.applicationPermissions = options?.applicationPermissions || false;
        this.autoRegisterApplicationCommands = options?.autoRegisterApplicationCommands || false;
        this.default = {
            adminOnly: options.default?.adminOnly,
            registerApplicationCommand: options.default?.registerApplicationCommand,
            category: options.default?.category,
            channel: options.default?.channel,
            clientPermissions: options.default?.clientPermissions,
            cooldown: options.default?.cooldown,
            examples: options.default?.examples,
            type: options.default?.type,
            usage: options.default?.usage,
            userPermissions: options.default?.userPermissions,
        };
        this.guildId = options?.guildId;
        this.prefix = options?.prefix;
        this.registerStrategy = options.registerStrategy || constants_js_1.COMMANDS_MANAGER_STRATEGY.set;
    }
    /**
     * Create a command in the client's application commands
     * @param {Command} [command] Command to create
     * @param {Snowflake | undefined} [guildId] Guild ID where the order will be created
     * @returns {Promise<ApplicationCommand<Record<string, unknown>> | ApplicationCommand<{ guild: GuildResolvable }> | undefined>}
     */
    async createCommand(command, guildId) {
        if (!command)
            throw new Error('Command not found');
        const data = this.getApplicationCommandData(command);
        if (!data)
            return undefined;
        return guildId ? this.client.application?.commands.create(data, guildId) : this.client.application?.commands.create(data);
    }
    /**
     * Delete all commands from the client's application commands
     * @param {Snowflake | undefined} [guildId] Guild ID where all commands will be deleted
     * @returns {Promise<Collection<string, ApplicationCommand<{}>> | Collection<string, ApplicationCommand<{ guild: GuildResolvable }>> | undefined>}
     */
    async deleteAllCommands(guildId) {
        return guildId ? this.client.application?.commands.set([], guildId) : this.client.application?.commands.set([]);
    }
    /**
     * Removes an command from the client's application commands
     * @param {ApplicationCommandResolvable} command Command deleted
     * @param {Snowflake | undefined} [guildId] Guild ID where the command will be deleted
     * @returns {Promise<ApplicationCommand<{ guild: GuildResolvable }> | null | undefined>}
     */
    async deleteCommand(command, guildId) {
        if (!command)
            throw new Error('Command not found');
        return guildId
            ? this.client.application?.commands.delete(command, guildId)
            : this.client.application?.commands.delete(command);
    }
    /**
     * Edit an command with a new command in the client's application commands
     * @param {ApplicationCommandResolvable} oldCommand Command edited
     * @param {Command} newCommand The new command that will take the place of the old one
     * @param {Snowflake | undefined} [guildId] Guild ID where the order will be edited
     * @returns {Promise<ApplicationCommand<{}> | ApplicationCommand<{ guild: GuildResolvable }> | undefined>}
     */
    async editCommand(oldCommand, newCommand, guildId) {
        if (!oldCommand)
            throw new Error('Old Command not found');
        if (!newCommand)
            throw new Error('New Command not found');
        const data = this.getApplicationCommandData(newCommand);
        if (!data)
            return undefined;
        return guildId
            ? this.client.application?.commands.edit(oldCommand, data, guildId)
            : this.client.application?.commands.edit(oldCommand, data);
    }
    /**
     * Get data of application command
     * @param {Command} [command] The command to obtain data
     * @returns {ApplicationCommandData | null}
     */
    getApplicationCommandData(command) {
        if (!command)
            return null;
        if (command.type === constants_js_1.COMMAND_TYPE.cmdMsg)
            return null;
        const newType = this.renameCommandType(command.type);
        if (!newType)
            return null;
        const base = {
            type: newType,
            name: command.name,
            nameLocalizations: command.nameLocalizations,
            description: '',
            defaultMemberPermissions: undefined,
            dmPermission: undefined,
        };
        if (this.applicationPermissions) {
            base.defaultMemberPermissions = command.userPermissions;
            base.dmPermission = command.channel === constants_js_1.COMMAND_CHANNEL.dm || command.channel === constants_js_1.COMMAND_CHANNEL.global ? true : false;
        }
        if (command.type === constants_js_1.COMMAND_TYPE.cmdSlash) {
            return {
                ...base,
                description: command.description,
                descriptionLocalizations: command.descriptionLocalizations,
                options: command.options,
            };
        }
        if (command.type === constants_js_1.COMMAND_TYPE.ctxMsg || command.type === constants_js_1.COMMAND_TYPE.ctxUser) {
            return {
                ...base,
            };
        }
        return null;
    }
    /**
     * Get an array of ApplicationCommandData from a collection of commands;
     * @param {Collection<string, Command>} [commands] The commandsToRegister
     * @returns {ApplicationCommandData[] | null}
     */
    getAllApplicationCommandData(commands) {
        if (!commands || (commands && !commands.size))
            return null;
        const data = [];
        for (const [, structures] of commands) {
            if (!structures || !structures.length)
                continue;
            for (const command of structures) {
                const commandData = this.getApplicationCommandData(command);
                if (commandData && command.registerApplicationCommand)
                    data.push(commandData);
            }
        }
        if (data.length)
            return data;
        return null;
    }
    /**
     * Load all commands in collection
     * @returns {Promise<Collection<string, Command[] | undefined>}
     */
    async loadAll() {
        const loader = new Loader_js_1.Loader(this.client, this.directory, 'name', {
            manager: this,
            instance: index_js_3.Command,
            asyncRead: this.asyncRead,
        });
        this.commands = await loader.load();
        new index_js_1.ShewenyInformation(this.client, `- Commands loaded : ${this.commands.size}`);
        if (this.commands?.size && this.autoRegisterApplicationCommands) {
            await this.registerApplicationCommands(this.commands, this.guildId);
        }
        return this.commands;
    }
    /**
     * Set all application commands from the collection of commands in the client application
     * @param {Collection<string, Command> | undefined} [commands] Collection of the commands
     * @returns {Promise<Collection<Snowflake, ApplicationCommand<{}>> | Collection<Snowflake, ApplicationCommand<{ guild: GuildResolvable }>> | undefined>}
     */
    async registerApplicationCommands(commands, guildId) {
        if (guildId && guildId instanceof Array)
            return guildId.every(id => this.registerApplicationCommands(commands, id));
        if (!commands)
            throw new Error('Commands not found');
        const data = this.getAllApplicationCommandData(commands);
        if (!data || (data && !data.length))
            return;
        await this.client.awaitReady();
        if (this.registerStrategy === constants_js_1.COMMANDS_MANAGER_STRATEGY.set) {
            if (guildId)
                await this.client.application?.commands.set(data, guildId);
            else
                await this.client.application?.commands.set(data);
        }
        if (this.registerStrategy === constants_js_1.COMMANDS_MANAGER_STRATEGY.create) {
            for (const command of data) {
                if (guildId)
                    await this.client.application?.commands.create(command, guildId);
                else
                    await this.client.application?.commands.create(command);
            }
        }
        return true;
    }
    /**
     * Rename command type to the type of Application command
     * @param {"SLASH_COMMAND" | "CONTEXT_MENU_USER" | "CONTEXT_MENU_MESSAGE"} type Type of command
     * @returns {ApplicationCommandType | undefined}
     */
    renameCommandType(type) {
        if (type === constants_js_1.COMMAND_TYPE.cmdSlash)
            return discord_js_1.ApplicationCommandType.ChatInput;
        if (type === constants_js_1.COMMAND_TYPE.ctxMsg)
            return discord_js_1.ApplicationCommandType.Message;
        if (type === constants_js_1.COMMAND_TYPE.ctxUser)
            return discord_js_1.ApplicationCommandType.User;
        return undefined;
    }
    /**
     * Unload all commands
     * @returns {void}
     */
    unloadAll() {
        this.commands = new discord_js_1.Collection();
        this.client.collections.commands.clear();
    }
}
exports.CommandsManager = CommandsManager;
//# sourceMappingURL=CommandsManager.js.map