"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventsManager = void 0;
const node_events_1 = require("node:events");
const Loader_js_1 = require("../utils/Loader.js");
const index_js_1 = require("../helpers/index.js");
const index_js_2 = require("./index.js");
const index_js_3 = require("../structures/index.js");
const discord_js_1 = require("discord.js");
/**
 * Manager for Events
 */
class EventsManager extends index_js_2.BaseManager {
    /**
     * Constructor to manage events
     * @param {ShewenyClient} [client] Client framework
     * @param {EventsManagerOptions} [options] The options of the event manager
     */
    constructor(client, options) {
        super(client, options);
        /**
         * Default data for the events
         * @type {EventsManagerDefaultOptions}
         */
        Object.defineProperty(this, "default", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Collection of the events
         * @type {Collection<string, Event[]> | undefined}
         */
        Object.defineProperty(this, "events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.default = {
            emitter: options.default?.emitter,
            once: options.default?.once,
        };
    }
    /**
     * Load all events in collection
     * @returns {Promise<Collection<string, Event[]> | undefined>} The events to load
     */
    async loadAll() {
        const loader = new Loader_js_1.Loader(this.client, this.directory, 'name', {
            manager: this,
            instance: index_js_3.Event,
            asyncRead: this.asyncRead,
        });
        this.events = await loader.load();
        new index_js_1.ShewenyInformation(this.client, `- Events loaded : ${this.events.size}`);
        // Register
        await this.registerAll(this.events);
        return this.events;
    }
    /**
     * Emit all events in collection
     * @param {Collection<string, Event[]> | undefined} [events] Events collection that will be emit
     * @returns {Promise<void>}
     */
    async registerAll(events) {
        if (!events)
            throw new Error('No events found');
        for (const [name, evts] of events) {
            if (evts && evts.length) {
                for (const evt of evts) {
                    if (!(evt.emitter instanceof node_events_1.EventEmitter))
                        throw new TypeError(`Event ${name} does not have a valid emitter.`);
                    if (evt.once)
                        evt.emitter.once(name, (...args) => evt.execute(...args));
                    else
                        evt.emitter.on(name, (...args) => evt.execute(...args));
                }
            }
        }
    }
    /**
     * Unload all events
     * @returns {void}
     */
    unloadAll() {
        this.events = new discord_js_1.Collection();
        this.client.collections.events.clear();
    }
}
exports.EventsManager = EventsManager;
//# sourceMappingURL=EventsManager.js.map