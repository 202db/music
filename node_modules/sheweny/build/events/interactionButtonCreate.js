"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const discord_js_1 = require("discord.js");
const index_js_1 = require("../helpers/index.js");
const constants_js_1 = require("../constants/constants.js");
async function run(client, interaction) {
    try {
        if (!client.collections.buttons)
            return;
        const buttons = [];
        for (const [, structure] of client.collections.buttons) {
            if (!structure || (structure && !structure.length))
                return;
            for (const button of structure) {
                for (const customId of button.customId) {
                    if (!(customId instanceof RegExp) && customId === interaction.customId) {
                        buttons.push(button);
                    }
                    else if (customId instanceof RegExp && customId.test(interaction.customId)) {
                        customId.lastIndex = 0;
                        buttons.push(button);
                    }
                }
            }
        }
        if (!buttons || (buttons && !buttons.length))
            return;
        for (const button of buttons) {
            await (async () => {
                if (!button.enabled)
                    return;
                if (button.before)
                    await button.before(interaction);
                /**
                 * Handle inhibitors
                 */
                const inhibitorsCollection = client.collections.inhibitors?.filter((is) => {
                    for (const i of is) {
                        return i.type.includes(constants_js_1.INHIBITOR_TYPE.button) || i.type.includes(constants_js_1.INHIBITOR_TYPE.all);
                    }
                    return false;
                });
                const inhibitorsArray = [];
                for (const [, inhibitors] of inhibitorsCollection) {
                    if (inhibitors && inhibitors.length) {
                        for (const inhibitor of inhibitors) {
                            inhibitorsArray.push(inhibitor);
                        }
                    }
                }
                if (inhibitorsArray && inhibitorsArray.length) {
                    const sorted = inhibitorsArray.sort((a, b) => b.priority - a.priority);
                    for (const i of sorted) {
                        if (!(await i.execute(button, interaction)))
                            return await i.onFailure(button, interaction);
                    }
                }
                /* ---------------COOLDOWNS--------------- */
                if (!client.admins?.includes(interaction.user.id)) {
                    if (!client.cooldowns.buttons.has(button.customId)) {
                        client.cooldowns.buttons.set(button.customId, new discord_js_1.Collection());
                    }
                    const timeNow = Date.now();
                    const tStamps = client.cooldowns.buttons.get(button.customId);
                    const cdAmount = (button.cooldown || 0) * 1000;
                    if (tStamps) {
                        if (tStamps.has(interaction.user.id)) {
                            const cdExpirationTime = (tStamps.get(interaction.user.id) || 0) + cdAmount;
                            if (timeNow < cdExpirationTime) {
                                // const timeLeft = (cdExpirationTime - timeNow) / 1000;
                                return client.managers.buttons?.emit(constants_js_1.BUTTON_EVENTS.cooldownLimit, interaction, cdExpirationTime - timeNow);
                            }
                        }
                        tStamps.set(interaction.user.id, timeNow);
                        setTimeout(() => tStamps.delete(interaction.user.id), cdAmount);
                    }
                }
                await button.execute(interaction);
            })();
        }
    }
    catch (err) {
        const e = err;
        new index_js_1.ShewenyError(client, e);
    }
}
exports.default = run;
//# sourceMappingURL=interactionButtonCreate.js.map